name: Coverage Check

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  coverage:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests with coverage
      run: npm run coverage:warn
      
    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-report
        path: coverage/
        retention-days: 7
        
    - name: Coverage Summary Comment
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const path = require('path');
          
          try {
            // Get changed files in PR
            const { data: prFiles } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            // Filter for JavaScript files in js/ directory
            const changedJSFiles = prFiles
              .filter(file => file.filename.startsWith('js/') && file.filename.endsWith('.js'))
              .map(file => file.filename);
            
            if (changedJSFiles.length === 0) {
              console.log('No JavaScript files changed in this PR');
              return;
            }
            
            // Read coverage summary
            const coverageFile = path.join(process.cwd(), 'coverage', 'coverage-summary.json');
            if (!fs.existsSync(coverageFile)) {
              console.log('Coverage summary not found');
              return;
            }
            
            const coverage = JSON.parse(fs.readFileSync(coverageFile, 'utf8'));
            
            // Helper functions
            const formatPct = (pct) => `${pct.toFixed(2)}%`;
            const getEmoji = (pct, target) => pct >= target ? 'üü¢' : pct >= target - 15 ? 'üü°' : 'üî¥';
            const getStatus = (pct, excellent, good) => 
              pct >= excellent ? 'Excellent' : pct >= good ? 'Good' : 'Needs Improvement';
            
            // Analyze changed files
            let changedFilesTable = '';
            let hasLowCoverage = false;
            let criticalFiles = [];
            
            changedJSFiles.forEach(filePath => {
              // Look for coverage data (try both relative and absolute paths)
              const fullPath = path.resolve(filePath);
              const relativePath = `./${filePath}`;
              
              let fileCoverage = coverage[filePath] || coverage[fullPath] || coverage[relativePath];
              
              // Try workspace prefix
              if (!fileCoverage) {
                const workspacePath = `workspace/${filePath}`;
                fileCoverage = coverage[workspacePath];
              }
              
              if (fileCoverage) {
                const fileName = path.basename(filePath);
                const lines = fileCoverage.lines.pct;
                const functions = fileCoverage.functions.pct;
                const branches = fileCoverage.branches.pct;
                
                const linesEmoji = getEmoji(lines, 95);
                const functionsEmoji = getEmoji(functions, 90);
                const branchesEmoji = getEmoji(branches, 85);
                
                const linesStatus = getStatus(lines, 95, 80);
                const uncoveredLines = fileCoverage.lines.total - fileCoverage.lines.covered;
                
                changedFilesTable += `| ${fileName} | ${linesEmoji} ${formatPct(lines)} | ${functionsEmoji} ${formatPct(functions)} | ${branchesEmoji} ${formatPct(branches)} | ${linesStatus} |\n`;
                
                // Check for critical issues
                if (lines < 50 || functions < 40) {
                  criticalFiles.push(`${fileName}: ${formatPct(lines)} lines, ${formatPct(functions)} functions`);
                }
                
                if (lines < 80) {
                  hasLowCoverage = true;
                }
              } else {
                // File not found in coverage (might be new)
                const fileName = path.basename(filePath);
                changedFilesTable += `| ${fileName} | ‚ùì No data | ‚ùì No data | ‚ùì No data | New file? |\n`;
                hasLowCoverage = true;
              }
            });
            
            // Overall coverage for context
            const total = coverage.total;
            const overallStatus = total.lines.pct >= 95 ? '‚úÖ **COMPLIANT**' : '‚ö†Ô∏è **NEEDS IMPROVEMENT**';
            
            // Build comment
            let commentBody = `## üß™ Coverage Report - Changed Files\n\n`;
            
            // Changed files table
            commentBody += `### üìÅ Files Changed in This PR\n\n`;
            commentBody += `| File | Lines | Functions | Branches | Status |\n`;
            commentBody += `|------|-------|-----------|----------|--------|\n`;
            commentBody += changedFilesTable;
            
            // Critical issues section
            if (criticalFiles.length > 0) {
              commentBody += `\n### üî¥ Critical Coverage Issues (ADR-0005 Violations)\n`;
              criticalFiles.forEach(file => {
                commentBody += `- ‚ùå ${file}\n`;
              });
              commentBody += `\nüí° These files violate ADR-0005 "Mandatory Testing for All Code"\n`;
            }
            
            // Overall project status
            commentBody += `\n### üìä Overall Project Coverage\n`;
            commentBody += `- **Lines**: ${formatPct(total.lines.pct)} (${total.lines.covered}/${total.lines.total})\n`;
            commentBody += `- **Functions**: ${formatPct(total.functions.pct)} (${total.functions.covered}/${total.functions.total})\n`;
            commentBody += `- **Branches**: ${formatPct(total.branches.pct)} (${total.branches.covered}/${total.branches.total})\n`;
            commentBody += `- **ADR-0005 Compliance**: ${overallStatus}\n`;
            
            // Recommendations
            commentBody += `\n### üí° Recommendations\n`;
            if (criticalFiles.length > 0) {
              commentBody += `üéØ **Priority**: Address ${criticalFiles.length} critical coverage issue(s) first\n`;
            }
            if (hasLowCoverage) {
              commentBody += `üìà **Action**: Add tests for changed files below 80% coverage\n`;
            } else {
              commentBody += `‚ú® **Great**: All changed files have good coverage!\n`;
            }
            commentBody += `üîç **Details**: Run \`npm run coverage:html\` for line-by-line analysis\n`;
            
            commentBody += `\n---\n*Coverage focused on changed files. See [ADR-0005](docs/adr/0005-mandatory-testing.md) for testing guidelines.*`;
            
            // Post comment on PR
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
            
          } catch (error) {
            console.log('Error posting coverage comment:', error.message);
            console.log('Error details:', error);
            // Don't fail the workflow if comment posting fails
          }