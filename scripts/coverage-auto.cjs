#!/usr/bin/env node

/**
 * Automated Coverage-Driven Development
 * 
 * This script automatically:
 * - Analyzes coverage gaps
 * - Creates test file stubs for missing tests
 * - Generates test templates for uncovered functions
 * - Provides specific line-by-line guidance
 * - Can be integrated into git hooks or CI workflows
 */

const fs = require('fs');
const path = require('path');

const COVERAGE_SUMMARY_PATH = path.join(process.cwd(), 'coverage', 'coverage-summary.json');
const DETAILED_COVERAGE_PATH = path.join(process.cwd(), 'coverage', 'coverage-final.json');

/**
 * Auto-generate test stubs for files with no tests
 */
const createTestStubs = async () => {
  const jsFiles = fs.readdirSync('js').filter(f => f.endsWith('.js'));
  const testFiles = fs.readdirSync('test').filter(f => f.endsWith('.test.js'));
  
  const missingTests = jsFiles.filter(jsFile => {
    const expectedTestFile = jsFile.replace('.js', '.test.js');
    return !testFiles.includes(expectedTestFile);
  });
  
  const createdStubs = [];
  
  for (const jsFile of missingTests) {
    const modulePath = `js/${jsFile}`;
    const testPath = `test/${jsFile.replace('.js', '.test.js')}`;
    
    if (!fs.existsSync(testPath)) {
      const testStub = generateTestStub(jsFile, modulePath);
      fs.writeFileSync(testPath, testStub);
      createdStubs.push(testPath);
    }
  }
  
  return createdStubs;
};

/**
 * Generate a test stub template
 */
const generateTestStub = (fileName, modulePath) => {
  const moduleName = fileName.replace('.js', '');
  const moduleVarName = moduleName.charAt(0).toUpperCase() + moduleName.slice(1);
  
  return `import { describe, it, beforeEach, afterEach } from 'mocha';
import { chai } from '../test/setup.js';
chai.should();

// Import module to test
// TODO: Update import path based on actual exports
// import * as ${moduleVarName} from '../${modulePath}';

describe('${moduleVarName} Module', () => {
  beforeEach(() => {
    global.resetLocalStorage();
    // TODO: Add any module-specific setup
  });

  afterEach(() => {
    global.resetLocalStorage();
    // TODO: Add any module-specific cleanup
  });

  describe('Module Functions', () => {
    it('should be implemented', () => {
      // TODO: Add actual tests for module functions
      // This stub was auto-generated by coverage automation
      // See ADR-0005 for testing requirements
      
      // Example test structure:
      // const result = ${moduleVarName}.someFunction(input);
      // result.should.equal(expectedOutput);
      
      true.should.be.true; // Placeholder
    });
    
    // TODO: Add tests for each exported function
    // Follow the pattern:
    // - Test normal cases
    // - Test edge cases  
    // - Test error conditions
    // Use should notation as per ADR-0005
  });
});
`;
};

/**
 * Extract uncovered functions from source files
 */
const extractUncoveredFunctions = (filePath) => {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const functions = [];
    
    // Simple regex to find function declarations and arrow functions
    const functionPatterns = [
      /export\s+const\s+(\w+)\s*=/g,
      /export\s+function\s+(\w+)/g,
      /const\s+(\w+)\s*=\s*\(/g,
      /function\s+(\w+)/g
    ];
    
    functionPatterns.forEach(pattern => {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        functions.push(match[1]);
      }
    });
    
    return [...new Set(functions)]; // Remove duplicates
  } catch (error) {
    return [];
  }
};

/**
 * Generate test templates for specific functions
 */
const generateFunctionTests = (fileName, functions) => {
  const moduleName = fileName.replace('.js', '');
  const tests = functions.map(funcName => {
    return `  describe('${funcName}', () => {
    it('should handle normal case', () => {
      // TODO: Implement test for ${funcName}
      // const result = ${moduleName}.${funcName}(validInput);
      // result.should.equal(expectedOutput);
      true.should.be.true; // Placeholder
    });
    
    it('should handle edge cases', () => {
      // TODO: Test edge cases for ${funcName}
      // Examples: empty input, null, undefined, boundary values
      true.should.be.true; // Placeholder
    });
    
    it('should handle error conditions', () => {
      // TODO: Test error conditions for ${funcName}
      // (() => ${moduleName}.${funcName}(invalidInput)).should.throw();
      true.should.be.true; // Placeholder
    });
  });`;
  }).join('\n\n');
  
  return tests;
};

/**
 * Create detailed coverage improvement plan
 */
const createImprovementPlan = async () => {
  if (!fs.existsSync(COVERAGE_SUMMARY_PATH)) {
    return { error: 'Run npm run test:coverage first' };
  }
  
  const coverage = JSON.parse(fs.readFileSync(COVERAGE_SUMMARY_PATH, 'utf8'));
  const plan = {
    timestamp: new Date().toISOString(),
    actions: [],
    files_analyzed: 0,
    stubs_created: 0,
    functions_identified: 0
  };
  
  // 1. Create missing test stubs
  const createdStubs = await createTestStubs();
  plan.stubs_created = createdStubs.length;
  
  if (createdStubs.length > 0) {
    plan.actions.push({
      type: 'TEST_STUBS_CREATED',
      files: createdStubs,
      description: 'Created test file stubs for modules without tests',
      next_step: 'Fill in the TODO comments with actual tests'
    });
  }
  
  // 2. Analyze low coverage files
  Object.entries(coverage).forEach(([filePath, fileCoverage]) => {
    if (!filePath.includes('.js') || filePath === 'total' || 
        filePath.includes('test') || filePath.includes('coverage')) {
      return;
    }
    
    plan.files_analyzed++;
    
    if (fileCoverage.lines.pct < 80) {
      const fileName = path.basename(filePath);
      const fullPath = path.resolve(filePath);
      
      // Try to find the actual file
      let actualPath = filePath;
      if (fs.existsSync(fileName)) actualPath = fileName;
      else if (fs.existsSync(`js/${fileName}`)) actualPath = `js/${fileName}`;
      else if (fs.existsSync(fullPath)) actualPath = fullPath;
      
      if (fs.existsSync(actualPath)) {
        const functions = extractUncoveredFunctions(actualPath);
        plan.functions_identified += functions.length;
        
        if (functions.length > 0) {
          const testTemplate = generateFunctionTests(fileName, functions);
          
          plan.actions.push({
            type: 'FUNCTION_TESTS_NEEDED',
            file: fileName,
            coverage: fileCoverage.lines.pct,
            uncovered_lines: fileCoverage.lines.total - fileCoverage.lines.covered,
            functions: functions,
            test_template: testTemplate,
            priority: fileCoverage.lines.pct < 50 ? 'CRITICAL' : 'HIGH',
            commands: [
              'npm run coverage:html',
              `# Focus on ${fileName}`,
              'npm test'
            ]
          });
        }
      }
    }
  });
  
  // 3. Generate summary recommendations
  const criticalFiles = plan.actions.filter(a => a.priority === 'CRITICAL').length;
  const highFiles = plan.actions.filter(a => a.priority === 'HIGH').length;
  
  plan.summary = {
    critical_files: criticalFiles,
    high_priority_files: highFiles,
    total_actions: plan.actions.length,
    adr_compliant: coverage.total.lines.pct >= 95,
    next_immediate_action: plan.actions.length > 0 ? plan.actions[0] : null
  };
  
  return plan;
};

/**
 * Auto-fix mode: Actually create test files with templates
 */
const autoFix = async () => {
  const plan = await createImprovementPlan();
  
  if (plan.error) {
    console.error(plan.error);
    return;
  }
  
  console.log('ðŸ¤– Automated Coverage Improvement');
  console.log('===================================');
  
  if (plan.stubs_created > 0) {
    console.log(`âœ… Created ${plan.stubs_created} test file stub(s)`);
  }
  
  if (plan.summary.critical_files > 0) {
    console.log(`ðŸ”´ ${plan.summary.critical_files} critical file(s) need immediate attention`);
  }
  
  if (plan.summary.high_priority_files > 0) {
    console.log(`ðŸŸ¡ ${plan.summary.high_priority_files} file(s) need coverage improvement`);
  }
  
  // Write detailed improvement plan
  const planFile = 'coverage-improvement-plan.json';
  fs.writeFileSync(planFile, JSON.stringify(plan, null, 2));
  console.log(`ðŸ“‹ Detailed plan written to ${planFile}`);
  
  // Output immediate next steps
  if (plan.summary.next_immediate_action) {
    const action = plan.summary.next_immediate_action;
    console.log('\nðŸŽ¯ Next Steps:');
    console.log(`1. Focus on: ${action.file} (${action.coverage.toFixed(1)}% coverage)`);
    console.log(`2. Functions to test: ${action.functions.join(', ')}`);
    console.log(`3. Run: npm run coverage:html`);
    console.log(`4. Edit test file and add function tests`);
  }
  
  return plan;
};

// Command line interface
const command = process.argv[2] || 'plan';

switch (command) {
  case 'plan':
    createImprovementPlan().then(plan => {
      console.log(JSON.stringify(plan, null, 2));
    });
    break;
    
  case 'auto':
  case 'fix':
    autoFix();
    break;
    
  case 'stubs':
    createTestStubs().then(stubs => {
      if (stubs.length > 0) {
        console.log('Created test stubs:');
        stubs.forEach(stub => console.log(`  - ${stub}`));
      } else {
        console.log('No missing test stubs needed');
      }
    });
    break;
    
  default:
    console.log('Usage: node coverage-auto.cjs [plan|auto|stubs]');
    console.log('  plan  - Generate improvement plan (default)');
    console.log('  auto  - Auto-create test stubs and improvement plan');
    console.log('  stubs - Only create missing test file stubs');
}